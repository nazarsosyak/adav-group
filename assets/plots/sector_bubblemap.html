---
layout: null
---
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sector Bubblemap</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden; /* kill scrollbar */
      background: transparent;
    }
    #chart {
      width: 100%;
      height: 100vh; /* fill iframe */
    }

    /* Minimal back button (only shown in drilldown) */
    #backBtn {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10;
      display: none;
      border: 1px solid rgba(0,0,0,.15);
      background: rgba(255,255,255,.9);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      font: 700 13px/1.1 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(0,0,0,.85);
    }
    #backBtn:hover { background: rgba(255,255,255,1); }
  </style>
</head>

<body>
  <button id="backBtn" type="button">← Back</button>
  <div id="chart"></div>

  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script>
  (function () {
    const el = document.getElementById("chart");
    const backBtn = document.getElementById("backBtn");
    const chart = echarts.init(el, null, { renderer: "canvas" });
    window.addEventListener("resize", () => chart.resize());

    // Data (your lists kept)
    const DATA = /* paste your DATA array here unchanged */ {{DATA_PLACEHOLDER}};
    // ↑ Replace the line above with your DATA array to keep this message short:
    //   const DATA = [ ... ];

    // -------------------------
    // non-overlapping packing
    // -------------------------
    function scaleSizes(values, minR, maxR) {
      const v = values.filter(Number.isFinite);
      const lo = Math.min(...v), hi = Math.max(...v);
      return values.map(x => {
        if (!Number.isFinite(x) || hi === lo) return (minR + maxR) / 2;
        const t = (x - lo) / (hi - lo);
        return minR + Math.pow(t, 0.6) * (maxR - minR);
      });
    }

    function packCircles(radii) {
      const placed = [];
      function collides(x,y,r) {
        for (const p of placed) {
          const dx=x-p.x, dy=y-p.y;
          const rr=r+p.r+10;
          if (dx*dx + dy*dy < rr*rr) return true;
        }
        return false;
      }
      const order = radii.map((r,i)=>({r,i})).sort((a,b)=>b.r-a.r);
      for (const it of order) {
        const r = it.r;
        let a = 0, ok = false;
        for (let k=0; k<10000; k++) {
          a += 0.33;
          const rad = 2.25 * a;
          const x = rad * Math.cos(a);
          const y = rad * Math.sin(a);
          if (!collides(x,y,r)) {
            placed.push({x,y,r,i:it.i});
            ok = true;
            break;
          }
        }
        if (!ok) placed.push({x: 260 + it.i*14, y: 0, r, i: it.i});
      }
      const out = Array(radii.length);
      for (const p of placed) out[p.i] = [p.x, p.y];
      return out;
    }

    function normalize(points, targetX=150, targetY=105) {
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
      for (const [x,y] of points) { minX=Math.min(minX,x); maxX=Math.max(maxX,x); minY=Math.min(minY,y); maxY=Math.max(maxY,y); }
      const w = Math.max(1e-9, maxX-minX), h = Math.max(1e-9, maxY-minY);
      const s = Math.min((2*targetX)/w, (2*targetY)/h);
      const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
      return points.map(([x,y]) => [(x-cx)*s, (y-cy)*s]);
    }

    // Label outline (NO textbox)
    const LABEL = {
      show: true,
      fontFamily: "system-ui, -apple-system, Segoe UI, Roboto, Arial",
      fontWeight: 800,
      fontSize: 12,
      color: "#111",
      textBorderColor: "rgba(255,255,255,.95)",
      textBorderWidth: 4,
      textShadowBlur: 0
    };

    function baseOption() {
      return {
        backgroundColor: "transparent",
        animation: true,
        animationDuration: 700,
        animationEasing: "cubicOut",
        xAxis: { show:false, min:-210, max:210 },
        yAxis: { show:false, min:-160, max:160 },
        tooltip: { show: false } // you asked: just bubble + text
      };
    }

    function renderSectors() {
      backBtn.style.display = "none";

      const weights = DATA.map(s => s.stocks.length);
      const radii = scaleSizes(weights, 56, 120);
      const pts = normalize(packCircles(radii), 150, 105);

      const seriesData = DATA.map((s,i) => ({
        name: s.name,
        value: [pts[i][0], pts[i][1], weights[i]],
        symbolSize: radii[i],
        sectorKey: s.key,
        itemStyle: {
          color: s.color,
          opacity: 1,
          borderWidth: 1.2,
          borderColor: "rgba(0,0,0,.18)",
          shadowBlur: 0
        }
      }));

      chart.setOption({
        ...baseOption(),
        series: [{
          type: "scatter",
          symbol: "circle",
          data: seriesData,
          label: { ...LABEL },
          labelLayout: { hideOverlap: true },
          emphasis: {
            scale: true,
            focus: "self",
            itemStyle: {
              borderWidth: 2,
              borderColor: "rgba(0,0,0,.28)",
              shadowBlur: 0
            }
          }
        }]
      }, true);
    }

    function renderStocks(sectorKey) {
      const s = DATA.find(x => x.key === sectorKey);
      if (!s) return;

      backBtn.style.display = "block";

      const weights = s.stocks.map((_,i)=> (s.stocks.length - i));
      const radii = scaleSizes(weights, 18, 64);
      const pts = normalize(packCircles(radii), 170, 120);

      const seriesData = s.stocks.map((x,i) => ({
        name: x.t,
        value: [pts[i][0], pts[i][1], weights[i]],
        symbolSize: radii[i],
        itemStyle: {
          color: s.color,
          opacity: 1,
          borderWidth: 1.1,
          borderColor: "rgba(0,0,0,.18)",
          shadowBlur: 0
        }
      }));

      chart.setOption({
        ...baseOption(),
        series: [{
          type: "scatter",
          symbol: "circle",
          data: seriesData,
          label: { ...LABEL, fontSize: 11 },
          labelLayout: { hideOverlap: true },
          emphasis: {
            scale: true,
            focus: "self",
            itemStyle: {
              borderWidth: 2,
              borderColor: "rgba(0,0,0,.28)",
              shadowBlur: 0
            }
          }
        }]
      }, true);
    }

    backBtn.addEventListener("click", renderSectors);

    chart.off("click");
    chart.on("click", (params) => {
      const k = params?.data?.sectorKey;
      if (k) renderStocks(k);
    });

    renderSectors();
  })();
  </script>
</body>
</html>
